 Sure, let's do this. Monads vs. Comonads, 60-second TikTok version, 0% rigor. So the key is that monads are easy to construct, but hard to destruct. Comonads are the opposite. They are easy to destruct, but hard or impossible to construct. The classic example of a monad is the list monad. It's very easy to construct. If you give me an A, I can return you a list of As, which is just the one element list. But a list is very difficult to destruct reliably. Like, if you give me a list of A, I might not be able to generate an element of A for you. For example, what if you gave me the empty list? Now, if instead we were working with something like an infinite stream, which is a comonad, we would always be able to pull out another element of A. There's always more elements of A waiting for us. Therefore, it's very easy to destruct. We have a function that takes any comonad of A and returns an A. However, constructing a comonad is far from guaranteed. Now, for both of them, we actually give ourselves an escape hatch for the more difficult operation. So for monads, we can destruct nested monads. And for comonads, we can construct nested comonads if we have one more comonad going on. Now, when are comonads useful? It's a little bit difficult. You can totally survive without them, right? Generally, though, they're advertised as a way to model stateful behavior, right? If you have a series of actions you can take, and in each of those actions, you have a series of more actions, and so on and so forth for potentially an infinite tree. As long as you have laziness in play, comonads do a pretty good job of describing those potential actions as data. Apparently, there's also really fun interplay when you have both a monad and a comonad interacting on the same thing. Cool stuff. Related topic is co-algebraic data structures, which have a similar relationship to comonads as monads do to algebraic data structures. We're getting off topic. That's more than our allotted 60 seconds.